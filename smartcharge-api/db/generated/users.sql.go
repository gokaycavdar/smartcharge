// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: users.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addUserBadge = `-- name: AddUserBadge :exec
INSERT INTO user_badges (user_id, badge_id)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

type AddUserBadgeParams struct {
	UserID  int32 `json:"user_id"`
	BadgeID int32 `json:"badge_id"`
}

func (q *Queries) AddUserBadge(ctx context.Context, arg AddUserBadgeParams) error {
	_, err := q.db.Exec(ctx, addUserBadge, arg.UserID, arg.BadgeID)
	return err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (name, email, password, role)
VALUES ($1, $2, $3, $4)
RETURNING id, name, email, password, role, coins, co2_saved, xp, created_at, updated_at
`

type CreateUserParams struct {
	Name     string `json:"name"`
	Email    string `json:"email"`
	Password string `json:"password"`
	Role     string `json:"role"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Name,
		arg.Email,
		arg.Password,
		arg.Role,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.Role,
		&i.Coins,
		&i.Co2Saved,
		&i.Xp,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDemoUser = `-- name: GetDemoUser :one
SELECT id, name, email, role FROM users WHERE email = 'driver@test.com'
`

type GetDemoUserRow struct {
	ID    int32  `json:"id"`
	Name  string `json:"name"`
	Email string `json:"email"`
	Role  string `json:"role"`
}

func (q *Queries) GetDemoUser(ctx context.Context) (GetDemoUserRow, error) {
	row := q.db.QueryRow(ctx, getDemoUser)
	var i GetDemoUserRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Role,
	)
	return i, err
}

const getLeaderboard = `-- name: GetLeaderboard :many
SELECT id, name, xp FROM users
WHERE role = 'DRIVER'
ORDER BY xp DESC
LIMIT $1
`

type GetLeaderboardRow struct {
	ID   int32  `json:"id"`
	Name string `json:"name"`
	Xp   int32  `json:"xp"`
}

func (q *Queries) GetLeaderboard(ctx context.Context, limit int32) ([]GetLeaderboardRow, error) {
	rows, err := q.db.Query(ctx, getLeaderboard, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLeaderboardRow{}
	for rows.Next() {
		var i GetLeaderboardRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Xp); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserBadges = `-- name: GetUserBadges :many
SELECT b.id, b.name, b.description, b.icon
FROM badges b
JOIN user_badges ub ON ub.badge_id = b.id
WHERE ub.user_id = $1
ORDER BY b.name ASC
`

func (q *Queries) GetUserBadges(ctx context.Context, userID int32) ([]Badge, error) {
	rows, err := q.db.Query(ctx, getUserBadges, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Badge{}
	for rows.Next() {
		var i Badge
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Icon,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, name, email, password, role, coins, co2_saved, xp, created_at, updated_at FROM users WHERE email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.Role,
		&i.Coins,
		&i.Co2Saved,
		&i.Xp,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, name, email, password, role, coins, co2_saved, xp, created_at, updated_at FROM users WHERE id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.Role,
		&i.Coins,
		&i.Co2Saved,
		&i.Xp,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserReservations = `-- name: GetUserReservations :many
SELECT r.id, r.date, r.hour, r.is_green, r.earned_coins, r.status,
       s.id AS station_id, s.name AS station_name, s.price AS station_price
FROM reservations r
JOIN stations s ON s.id = r.station_id
WHERE r.user_id = $1
ORDER BY r.id DESC
LIMIT $2
`

type GetUserReservationsParams struct {
	UserID int32 `json:"user_id"`
	Limit  int32 `json:"limit"`
}

type GetUserReservationsRow struct {
	ID           int32              `json:"id"`
	Date         pgtype.Timestamptz `json:"date"`
	Hour         string             `json:"hour"`
	IsGreen      bool               `json:"is_green"`
	EarnedCoins  int32              `json:"earned_coins"`
	Status       string             `json:"status"`
	StationID    int32              `json:"station_id"`
	StationName  string             `json:"station_name"`
	StationPrice float64            `json:"station_price"`
}

func (q *Queries) GetUserReservations(ctx context.Context, arg GetUserReservationsParams) ([]GetUserReservationsRow, error) {
	rows, err := q.db.Query(ctx, getUserReservations, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserReservationsRow{}
	for rows.Next() {
		var i GetUserReservationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.Hour,
			&i.IsGreen,
			&i.EarnedCoins,
			&i.Status,
			&i.StationID,
			&i.StationName,
			&i.StationPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserStations = `-- name: GetUserStations :many
SELECT id, name, price, lat, lng
FROM stations
WHERE owner_id = $1
ORDER BY id ASC
`

type GetUserStationsRow struct {
	ID    int32   `json:"id"`
	Name  string  `json:"name"`
	Price float64 `json:"price"`
	Lat   float64 `json:"lat"`
	Lng   float64 `json:"lng"`
}

func (q *Queries) GetUserStations(ctx context.Context, ownerID pgtype.Int4) ([]GetUserStationsRow, error) {
	rows, err := q.db.Query(ctx, getUserStations, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserStationsRow{}
	for rows.Next() {
		var i GetUserStationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Price,
			&i.Lat,
			&i.Lng,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUserProfile = `-- name: UpdateUserProfile :one
UPDATE users
SET name = $2, email = $3, updated_at = NOW()
WHERE id = $1
RETURNING id, name, email, password, role, coins, co2_saved, xp, created_at, updated_at
`

type UpdateUserProfileParams struct {
	ID    int32  `json:"id"`
	Name  string `json:"name"`
	Email string `json:"email"`
}

func (q *Queries) UpdateUserProfile(ctx context.Context, arg UpdateUserProfileParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserProfile, arg.ID, arg.Name, arg.Email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.Role,
		&i.Coins,
		&i.Co2Saved,
		&i.Xp,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserStats = `-- name: UpdateUserStats :one
UPDATE users
SET coins = coins + $2, co2_saved = co2_saved + $3, xp = xp + $4, updated_at = NOW()
WHERE id = $1
RETURNING id, name, email, password, role, coins, co2_saved, xp, created_at, updated_at
`

type UpdateUserStatsParams struct {
	ID       int32   `json:"id"`
	Coins    int32   `json:"coins"`
	Co2Saved float64 `json:"co2_saved"`
	Xp       int32   `json:"xp"`
}

func (q *Queries) UpdateUserStats(ctx context.Context, arg UpdateUserStatsParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserStats,
		arg.ID,
		arg.Coins,
		arg.Co2Saved,
		arg.Xp,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.Role,
		&i.Coins,
		&i.Co2Saved,
		&i.Xp,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
